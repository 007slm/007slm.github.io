<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>slm的研发笔记</title>
    <link>https://007slm.github.io/</link>
    <description>Recent content on slm的研发笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://007slm.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://007slm.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://007slm.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于后端进度条的实现</title>
      <link>https://007slm.github.io/post/%E5%90%8E%E7%AB%AF%E5%88%86%E7%89%87%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E8%83%BD%E5%8A%9B/</link>
      <pubDate>Tue, 09 Oct 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/%E5%90%8E%E7%AB%AF%E5%88%86%E7%89%87%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E8%83%BD%E5%8A%9B/</guid>
      
        <description>

&lt;h2 id=&#34;关于后端进度条的实现&#34;&gt;关于后端进度条的实现&lt;/h2&gt;

&lt;h4 id=&#34;java代码部分&#34;&gt;java代码部分&lt;/h4&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;for (int i =0;i&amp;lt;10;i++) {
  try {
      TimeUnit.SECONDS.sleep(1);
  } catch (InterruptedException e) {
      e.printStackTrace();
  }
  writer.print(i);
  writer.flush();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;重点写一个trunk后要及时flush&lt;/p&gt;

&lt;h4 id=&#34;js部分&#34;&gt;js部分&lt;/h4&gt;

&lt;p&gt;得益于fetch api中关于getReader的能力 可以让我们及时读取每个分片（trunk）的数据&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  fetch(require.toUrl(&amp;quot;$UI/demo/mock.j&amp;quot;)).then(function (response) {
      let reader = response.body.getReader();
      let decoder = new TextDecoder();
      return readData();
      function readData() {
          return reader.read().then(function (data) {
              var value = data.value,done = data.done;
              value = new TextDecoder(&amp;quot;utf-8&amp;quot;).decode(value);
              console.log(value);
              if (done) {
                  console.log(&#39;Stream complete&#39;);
                  return;
              }
              return readData();
          });
      }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;效果如下&#34;&gt;效果如下：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7KDeGT7.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>博客发文流程</title>
      <link>https://007slm.github.io/post/%E5%8D%9A%E5%AE%A2%E5%8F%91%E6%96%87%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 14 Sep 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/%E5%8D%9A%E5%AE%A2%E5%8F%91%E6%96%87%E6%B5%81%E7%A8%8B/</guid>
      
        <description>&lt;p&gt;cd g:\hugo\blog
本地查看效果
hugo server &amp;ndash;buildDrafts
编译发布
hugo &amp;ndash;baseUrl=&amp;ldquo;&lt;a href=&#34;https://007slm.github.io/&#34;&gt;https://007slm.github.io/&lt;/a&gt;
git 提交&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>微信体系梳理</title>
      <link>https://007slm.github.io/post/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</link>
      <pubDate>Fri, 14 Sep 2018 10:43:33 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</guid>
      
        <description>

&lt;h2 id=&#34;微信体系梳理&#34;&gt;微信体系梳理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;微信开放平台是微信体系的总称&lt;/strong&gt;
open.weixin.com
下面包含
- 网站应用  web
- 移动应用 app
- 公众账号  对应公众平台（也就是公众号）
- 第三方平台 一般来说是帮助用户运行公众号的的&lt;/p&gt;

&lt;h3 id=&#34;公众账号-叫做公众平台-公众号是个总称&#34;&gt;公众账号  叫做公众平台  公众号是个总称&lt;/h3&gt;

&lt;p&gt;mp.weixin.com
里面包含
- 订阅号  &amp;ndash;天天发文章的那种  一天一篇群发消息限制
- 服务号 –类似招行银行信用卡 为公众提供服务的  一个月4篇群发消息限制
- 企业号（后来改名为企业微信）  &amp;ndash; 需要先邀请用户才能参与的 适用用企业内部适用
- 小程序 –为了解决服务号的网页在浏览器中性能卡顿而出的一种专门解决技术问题的公众号类型。&lt;br /&gt;
    一次支付行为可以可以下发3条消息
    一次form提交行为可以在7天内发送1条消息&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>nginx &#43; openresty 备忘</title>
      <link>https://007slm.github.io/post/openresty%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://007slm.github.io/post/openresty%E7%9B%B8%E5%85%B3/</guid>
      
        <description>

&lt;h3 id=&#34;nginx-openresty-备忘&#34;&gt;nginx + openresty 备忘&lt;/h3&gt;

&lt;p&gt;nginx的开发者提供了一种简单、粗暴的方式来实现日志文件的切换。来自官网的一篇文章Log Rotation介绍了这种方法，核心脚本如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv access.log access.log.0
kill -USR1 `cat master.nginx.pid`
sleep 1# 
do something with access.log.0
gzip access.log.0
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;nginx指令&#34;&gt;nginx指令&lt;/h3&gt;

&lt;p&gt;set_header 设置response header
proxy_set_header 设置request header&lt;/p&gt;

&lt;p&gt;openresty&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;request部分&lt;/strong&gt;
header赋值
ngx.req.set_header(&amp;lsquo;X-Credential-Username&amp;rsquo;, username);
header取值
local headers = ngx.req.get_headers();
headers[&amp;ldquo;X-Credential-Username&amp;rdquo;];
&lt;strong&gt;response部分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Reading ngx.header.HEADER will return the value of the response header named HEADER.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ngx.var.VARIABLE&lt;/strong&gt;
Read and write Nginx variable values.
Note that only already defined nginx variables can be written to. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; location /foo {
     set $my_var &#39;&#39;; # this line is required to create $my_var at config time
     content_by_lua_block {
         ngx.var.my_var = 123;
         ...
     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;使用-nginx-内置绑定变量&#34;&gt;使用 Nginx 内置绑定变量&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt;作为一个成熟、久经考验的负载均衡软件，与其提供丰富、完整的内置变量是分不开的，它极大增加了对&lt;code&gt;Nginx&lt;/code&gt;网络行为的控制细度。这些变量大部分都是在请求进入时解析的，并把他们缓存到请求&lt;code&gt;cycle&lt;/code&gt;中，方便下一次获取使用。首先来看看&lt;code&gt;Nginx&lt;/code&gt;对都开放了那些&lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参看下表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$arg_name&lt;/td&gt;
&lt;td&gt;请求中的name参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$args&lt;/td&gt;
&lt;td&gt;请求中的参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$binary_remote_addr&lt;/td&gt;
&lt;td&gt;远程地址的二进制表示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$body_bytes_sent&lt;/td&gt;
&lt;td&gt;已发送的消息体字节数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$content_length&lt;/td&gt;
&lt;td&gt;HTTP请求信息里的&amp;rdquo;Content-Length&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$content_type&lt;/td&gt;
&lt;td&gt;请求信息里的&amp;rdquo;Content-Type&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$document_root&lt;/td&gt;
&lt;td&gt;针对当前请求的根路径设置值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$document_uri&lt;/td&gt;
&lt;td&gt;与$uri相同; 比如 /test2/test.php&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$host&lt;/td&gt;
&lt;td&gt;请求信息中的&amp;rdquo;Host&amp;rdquo;，如果请求中没有Host行，则等于设置的服务器名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$hostname&lt;/td&gt;
&lt;td&gt;机器名使用 gethostname系统调用的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_cookie&lt;/td&gt;
&lt;td&gt;cookie 信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_referer&lt;/td&gt;
&lt;td&gt;引用地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_user_agent&lt;/td&gt;
&lt;td&gt;客户端代理信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_via&lt;/td&gt;
&lt;td&gt;最后一个访问服务器的Ip地址。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_x_forwarded_for&lt;/td&gt;
&lt;td&gt;相当于网络访问路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$is_args&lt;/td&gt;
&lt;td&gt;如果请求行带有参数，返回“?”，否则返回空字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$limit_rate&lt;/td&gt;
&lt;td&gt;对连接速率的限制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$nginx_version&lt;/td&gt;
&lt;td&gt;当前运行的nginx版本号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$pid&lt;/td&gt;
&lt;td&gt;worker进程的PID&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$query_string&lt;/td&gt;
&lt;td&gt;与$args相同&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$realpath_root&lt;/td&gt;
&lt;td&gt;按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$remote_addr&lt;/td&gt;
&lt;td&gt;客户端IP地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$remote_port&lt;/td&gt;
&lt;td&gt;客户端端口号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$remote_user&lt;/td&gt;
&lt;td&gt;客户端用户名，认证用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request&lt;/td&gt;
&lt;td&gt;用户请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_body&lt;/td&gt;
&lt;td&gt;这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_body_file&lt;/td&gt;
&lt;td&gt;客户端请求主体信息的临时文件名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_completion&lt;/td&gt;
&lt;td&gt;如果请求成功，设为&amp;rdquo;OK&amp;rdquo;；如果请求未完成或者不是一系列请求中最后一部分则设为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_filename&lt;/td&gt;
&lt;td&gt;当前请求的文件路径名，比如/opt/nginx/www/test.php&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_method&lt;/td&gt;
&lt;td&gt;请求的方法，比如&amp;rdquo;GET&amp;rdquo;、&amp;rdquo;POST&amp;rdquo;等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_uri&lt;/td&gt;
&lt;td&gt;请求的URI，带参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$scheme&lt;/td&gt;
&lt;td&gt;所用的协议，比如http或者是https&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_addr&lt;/td&gt;
&lt;td&gt;服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_name&lt;/td&gt;
&lt;td&gt;请求到达的服务器名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_port&lt;/td&gt;
&lt;td&gt;请求到达的服务器端口号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_protocol&lt;/td&gt;
&lt;td&gt;请求的协议版本，&amp;rdquo;HTTP/1.0&amp;rdquo;或&amp;rdquo;HTTP/1.1&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$uri&lt;/td&gt;
&lt;td&gt;请求的URI，可能和最初的值有不同，比如经过重定向之类的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实这还不是全部，&lt;code&gt;Nginx&lt;/code&gt;在不停迭代更新是一个原因，还有一个是有些变量太冷门，借助它们，会有很多玩法。&lt;/p&gt;

&lt;p&gt;首先，在&lt;code&gt;OpenResty&lt;/code&gt;中如何引用这些变量呢？参考 &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxvarvariable&#34;&gt;ngx.var.VARIABLE&lt;/a&gt; 小节。&lt;/p&gt;

&lt;p&gt;利用这些内置变量，来做一个简单的数学求和运算例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;    server {
        listen    80;
        server_name  localhost;

        location /sum {
            #处理业务
           content_by_lua_block {
                local a = tonumber(ngx.var.arg_a) or 0
                local b = tonumber(ngx.var.arg_b) or 0
                ngx.say(&amp;quot;sum: &amp;quot;, a + b )
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜  ~  curl &#39;http://127.0.0.1/sum?a=11&amp;amp;b=12&#39;
sum: 23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;特别注意&lt;/strong&gt;
access_by_lua_content阶段取不到location中通过proxy_set_header设置的值&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;http://static.zybuluo.com/yishuailuo/1ur8ovkz7n5n36ojwas0t45l/image.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ngx.header.HEADER
syntax: ngx.header.HEADER = VALUE&lt;/p&gt;

&lt;p&gt;syntax: value = ngx.header.HEADER&lt;/p&gt;

&lt;p&gt;context: rewrite_by_lua&lt;em&gt;, access_by_lua&lt;/em&gt;, content_by_lua&lt;em&gt;, header_filter_by_lua&lt;/em&gt;, body_filter_by_lua&lt;em&gt;, log_by_lua&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Set, add to, or clear the current request&amp;rsquo;s HEADER response header that is to be sent.&lt;/p&gt;

&lt;p&gt;获取header值和赋值&lt;/p&gt;

&lt;p&gt;&amp;ndash; equivalent to ngx.header[&amp;ldquo;Content-Type&amp;rdquo;] = &amp;lsquo;text/plain&amp;rsquo;
 ngx.header.content_type = &amp;lsquo;text/plain&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;ngx.header[&amp;ldquo;X-My-Header&amp;rdquo;] = &amp;lsquo;blah blah&amp;rsquo;;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
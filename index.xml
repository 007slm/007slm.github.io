<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>slm的研发笔记</title>
    <link>https://007slm.github.io/</link>
    <description>Recent content on slm的研发笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://007slm.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://007slm.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://007slm.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>antlr备忘</title>
      <link>https://007slm.github.io/post/antlr/</link>
      <pubDate>Fri, 26 Oct 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/antlr/</guid>
      
        <description>

&lt;h3 id=&#34;antlr-备忘&#34;&gt;antlr 备忘&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;enter every rule&lt;/li&gt;
&lt;li&gt;enter expression&lt;/li&gt;
&lt;li&gt;exit expression&lt;/li&gt;
&lt;li&gt;exit every rule&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>https连接提示pkix path错误</title>
      <link>https://007slm.github.io/post/java%E8%BF%9E%E6%8E%A5https%E6%9C%8D%E5%8A%A1pkix-path%E9%94%99%E8%AF%AF/</link>
      <pubDate>Fri, 26 Oct 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/java%E8%BF%9E%E6%8E%A5https%E6%9C%8D%E5%8A%A1pkix-path%E9%94%99%E8%AF%AF/</guid>
      
        <description>

&lt;p&gt;关于java中用httpclient访问https服务报错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1514)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1026)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:961)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)
    at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:559)
    at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:185)
    at sun.net.www.protocol.https.HttpsURLConnectionImpl.connect(HttpsURLConnectionImpl.java:153)
    at TestSecuredConnection.testConnectionTo(TestSecuredConnection.java:30)
    at TestSecuredConnection.main(TestSecuredConnection.java:16)
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387)
    at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)
    at sun.security.validator.Validator.validate(Validator.java:260)
    at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324)
    at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229)
    at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1496)
    ... 12 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:141)
    at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:126)
    at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382)
    ... 18 more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要看这一句，是说没有找到的指定的证书。&lt;/p&gt;

&lt;p&gt;我们知道ssl握手是又服务端返回证书信息，客户端进行校验，这里有个隐藏的规则，因为证书是链式签发的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;root ca&amp;ndash;&amp;gt;一级ca -—&amp;gt;二级ca &amp;ndash;&amp;gt;我的网站&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多用户在部署证书的时候都只部署了自己的证书，这就造成浏览器一般会把受信任的证书补全，类似curl，httpclient等工具会利用操作系统本地的cert列表 eg：/etc/local/cert 来补全公信的证书，某些时候如果操作系统的cert不全或者java的security\cacert里面没有添加公信ca就会出现问题了。（不同版本的jre带的cacert可能会不一样，所以同样的代码 有些环境就不报错）&lt;/p&gt;

&lt;h4 id=&#34;解决办法&#34;&gt;解决办法：&lt;/h4&gt;

&lt;p&gt;服务器部署证书的时候部署全证书链，如下图即为典型的没有添加全证书链&lt;/p&gt;

&lt;p&gt;通过myssl校验证书信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CESb3vS.png&#34; alt=&#34;enter image description here&#34; /&gt;
在kong的certificate中补全证书链信息后就正常了 用java验证也通过：
验证代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void testConnectionTo(String aURL) throws Exception {
        URL destinationURL = new URL(aURL);
        HttpsURLConnection conn = (HttpsURLConnection) destinationURL
                .openConnection();
        conn.connect();
        Certificate[] certs = conn.getServerCertificates();
        for (Certificate cert : certs) {
            System.out.println(&amp;quot;Certificate is: &amp;quot; + cert);
            if(cert instanceof X509Certificate) {
                try {
                    ( (X509Certificate) cert).checkValidity();
                    System.out.println(&amp;quot;Certificate is active for current date&amp;quot;);
                } catch(CertificateExpiredException cee) {
                    System.out.println(&amp;quot;Certificate is expired&amp;quot;);
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[2]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=false
AuthorityInfoAccess [
  [
   accessMethod: ocsp
   accessLocation: URIName: http://ocsp2.digicert.com
, 
   accessMethod: caIssuers
   accessLocation: URIName: http://cacerts.digitalcertvalidation.com/TrustAsiaTLSRSACA.crt
]
]

&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>git常用命令</title>
      <link>https://007slm.github.io/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 18 Oct 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      
        <description>

&lt;h3 id=&#34;创建新的github仓库&#34;&gt;创建新的github仓库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git init&lt;/li&gt;
&lt;li&gt;git add README.md&lt;/li&gt;
&lt;li&gt;git commit -m &amp;ldquo;readme.md&amp;rdquo;&lt;/li&gt;
&lt;li&gt;git remote add origin &lt;a href=&#34;https://github.com/lonelyc/MyRepo.git&#34;&gt;https://github.com/lonelyc/MyRepo.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;git push -u origin master&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;在新的仓库中创建分支&#34;&gt;在新的仓库中创建分支&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;获取远程分支列表 git branch -r&lt;/li&gt;
&lt;li&gt;在本地创建新的分支 git branch newbranch&lt;/li&gt;
&lt;li&gt;切换到新的分支 git checkout newbranch&lt;/li&gt;
&lt;li&gt;将新的分支推送到github git push origin newbranch&lt;/li&gt;
&lt;li&gt;在本地删除一个分支： git branch -d newbranch&lt;/li&gt;
&lt;li&gt;在github远程端删除一个分支： git push origin :newbranch (分支名前的冒号代表删除)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;直接使用git-pull和git-push的设置&#34;&gt;直接使用git pull和git push的设置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git branch &amp;ndash;set-upstream-to=origin/master master&lt;/li&gt;
&lt;li&gt;git branch &amp;ndash;set-upstream-to=origin/ThirdParty ThirdParty&lt;/li&gt;
&lt;li&gt;git config &amp;ndash;global push.default matching&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;github-收到dns污染加速方案-hosts中添加&#34;&gt;github 收到dns污染加速方案 hosts中添加&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;192.30.253.112 github.com&lt;/li&gt;
&lt;li&gt;151.101.72.249 github.global.ssl.fastly.net&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;本地修改了许多文件-其中有些是新增的-因为开发需要这些都不要了-想要丢弃掉-可以使用如下命令&#34;&gt;本地修改了许多文件，其中有些是新增的，因为开发需要这些都不要了，想要丢弃掉，可以使用如下命令：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态&lt;/li&gt;
&lt;li&gt;git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。&lt;/li&gt;
&lt;li&gt;git reset --hard HASH #返回到某个节点，不保留修改。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git reset --soft HASH #返回到某个节点。保留修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git clean -df #返回到某个节点&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git clean 参数
-n 显示 将要 删除的 文件 和  目录
-f 删除 文件
-df 删除 文件 和 目录12345678910&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也可以使用：
- git checkout . &amp;amp;&amp;amp; git clean -xdf&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>k8s常用命令</title>
      <link>https://007slm.github.io/post/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 18 Oct 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      
        <description>

&lt;h4 id=&#34;获取namespace为-console-的pod列表&#34;&gt;获取namespace为 console 的pod列表&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kubectl get po -n console&lt;/p&gt;

&lt;p&gt;namespace console
container 为gateway
pod id 为console-deploy-7d9dc9f8c5-2lgtc&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kubectl exec -it console-deploy-7d9dc9f8c5-2lgtc -c gateway -n console /bin/bash&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>关于后端进度条的实现</title>
      <link>https://007slm.github.io/post/%E5%90%8E%E7%AB%AF%E5%88%86%E7%89%87%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E8%83%BD%E5%8A%9B/</link>
      <pubDate>Tue, 09 Oct 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/%E5%90%8E%E7%AB%AF%E5%88%86%E7%89%87%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E8%83%BD%E5%8A%9B/</guid>
      
        <description>

&lt;h2 id=&#34;关于后端进度条的实现&#34;&gt;关于后端进度条的实现&lt;/h2&gt;

&lt;h4 id=&#34;java代码部分&#34;&gt;java代码部分&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;for (int i =0;i&amp;lt;10;i++) {
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    writer.print(i);
    writer.flush();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点写一个trunk后要及时flush&lt;/p&gt;

&lt;h4 id=&#34;js部分&#34;&gt;js部分&lt;/h4&gt;

&lt;p&gt;得益于fetch api中关于getReader的能力 可以让我们及时读取每个分片（trunk）的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetch(require.toUrl(&amp;quot;$UI/demo/mock.j&amp;quot;)).then(function (response) {
    let reader = response.body.getReader();
    let decoder = new TextDecoder();
    return readData();
    function readData() {
        return reader.read().then(function (data) {
            var value = data.value,done = data.done;
            value = new TextDecoder(&amp;quot;utf-8&amp;quot;).decode(value);
            console.log(value);
            if (done) {
                console.log(&#39;Stream complete&#39;);
                return;
            }
            return readData();
        });
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;效果如下&#34;&gt;效果如下：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7KDeGT7.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>nginx日志重新挂载</title>
      <link>https://007slm.github.io/post/nginx%E6%97%A5%E5%BF%97/</link>
      <pubDate>Fri, 14 Sep 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/nginx%E6%97%A5%E5%BF%97/</guid>
      
        <description>&lt;p&gt;先移动日志文件&lt;/p&gt;

&lt;p&gt;mv /usr/local/openresty/nginx/logs/access.log /usr/local/openresty/nginx/logs/access.log.20161024&lt;/p&gt;

&lt;p&gt;发送信号重新打开日志文件&lt;/p&gt;

&lt;p&gt;kill -USR1 $(cat /usr/local/openresty/nginx/logs/nginx.pid)&lt;/p&gt;

&lt;p&gt;简单说明一下：&lt;/p&gt;

&lt;p&gt;1、在没有执行kill -USR1 &lt;code&gt;cat ${pid_path}&lt;/code&gt;之前，即便已经对文件执行了mv命令也只是改变了文件的名称，nginx还是会向新命名的文件” access.log.20161024”中照常写入日志数据。原因在于linux系统中，内核是根据文件描述符来找文件的&lt;/p&gt;

&lt;p&gt;2、USR1是自定义信号，也就是进程编写者自己确定收到这个信号该干什么。而在nginx中它自己编写了代码当接到USR1信号的时候让nginx重新打开日志文件（重新打开的日志就是配置文件中设置的位置和名称）&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ngxin日志数据查询</title>
      <link>https://007slm.github.io/post/nginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 14 Sep 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/nginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看时间最长的前300个请求
sed  -e &amp;rsquo;s/&amp;ldquo;//g&amp;rsquo; -e &amp;rsquo;s/?.*$//g&amp;rsquo; access.log | awk &amp;lsquo;{print $6,$1,$2,$3,$4,$5,$6,$10,$11,$12,$13,$14,$15,$16,$20}&amp;rsquo; | sort -rn |grep -v websocket|grep -v qrcodeLogin|grep -v wxEvent|grep -v wxevent| head -n 300&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后30000条记录 请求时间排序
tail -n 30000 access.log | sed  -e &amp;rsquo;s/&amp;ldquo;//g&amp;rsquo; -e &amp;rsquo;s/?.*$//g&amp;rsquo; | grep 20/Nov/2018 | awk &amp;lsquo;{print $10,$1,$2,$3,$4,$5,$6,$10,$11,$12,$13,$14,$15,$16,$20}&amp;rsquo; | sort -rn |awk &amp;lsquo;{print $7,$1,$2,$3,$4,$5,$6,$10,$11,$12,$13,$14,$15,$16,$20}&amp;rsquo; | sort -rn |grep -v websocket|grep -v qrcodeLogin|grep -v wxEvent|grep -v wxevent| head -n 500&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://k.justep.com/?controller=FileViewerController&amp;amp;action=image&amp;amp;file_id=5509&amp;amp;project_id=301&amp;amp;task_id=18850&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>博客发文流程</title>
      <link>https://007slm.github.io/post/%E5%8D%9A%E5%AE%A2%E5%8F%91%E6%96%87%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 14 Sep 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/%E5%8D%9A%E5%AE%A2%E5%8F%91%E6%96%87%E6%B5%81%E7%A8%8B/</guid>
      
        <description>&lt;p&gt;cd g:\hugo\blog
本地查看效果
hugo server &amp;ndash;buildDrafts
编译发布
hugo &amp;ndash;baseUrl=&amp;ldquo;&lt;a href=&#34;https://007slm.github.io/&#34;&gt;https://007slm.github.io/&lt;/a&gt;
git 提交&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>微信体系梳理</title>
      <link>https://007slm.github.io/post/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</link>
      <pubDate>Fri, 14 Sep 2018 10:43:33 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</guid>
      
        <description>

&lt;h2 id=&#34;微信体系梳理&#34;&gt;微信体系梳理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;微信开放平台是微信体系的总称&lt;/strong&gt;
open.weixin.com
下面包含
- 网站应用  web
- 移动应用 app
- 公众账号  对应公众平台（也就是公众号）
- 第三方平台 一般来说是帮助用户运行公众号的的&lt;/p&gt;

&lt;h3 id=&#34;公众账号-叫做公众平台-公众号是个总称&#34;&gt;公众账号  叫做公众平台  公众号是个总称&lt;/h3&gt;

&lt;p&gt;mp.weixin.com
里面包含
- 订阅号  &amp;ndash;天天发文章的那种  一天一篇群发消息限制
- 服务号 –类似招行银行信用卡 为公众提供服务的  一个月4篇群发消息限制
- 企业号（后来改名为企业微信）  &amp;ndash; 需要先邀请用户才能参与的 适用用企业内部适用
- 小程序 –为了解决服务号的网页在浏览器中性能卡顿而出的一种专门解决技术问题的公众号类型。&lt;br /&gt;
    一次支付行为可以可以下发3条消息
    一次form提交行为可以在7天内发送1条消息&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>nginx &#43; openresty 备忘</title>
      <link>https://007slm.github.io/post/openresty%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sun, 09 Sep 2018 11:30:16 +0800</pubDate>
      
      <guid>https://007slm.github.io/post/openresty%E7%9B%B8%E5%85%B3/</guid>
      
        <description>

&lt;h3 id=&#34;nginx-openresty-备忘&#34;&gt;nginx + openresty 备忘&lt;/h3&gt;

&lt;p&gt;nginx的开发者提供了一种简单、粗暴的方式来实现日志文件的切换。来自官网的一篇文章Log Rotation介绍了这种方法，核心脚本如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv access.log access.log.0
kill -USR1 `cat master.nginx.pid`
sleep 1# 
do something with access.log.0
gzip access.log.0
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;nginx指令&#34;&gt;nginx指令&lt;/h3&gt;

&lt;p&gt;set_header 设置response header
proxy_set_header 设置request header&lt;/p&gt;

&lt;p&gt;openresty&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;request部分&lt;/strong&gt;
header赋值
ngx.req.set_header(&amp;lsquo;X-Credential-Username&amp;rsquo;, username);
header取值
local headers = ngx.req.get_headers();
headers[&amp;ldquo;X-Credential-Username&amp;rdquo;];
&lt;strong&gt;response部分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Reading ngx.header.HEADER will return the value of the response header named HEADER.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ngx.var.VARIABLE&lt;/strong&gt;
Read and write Nginx variable values.
Note that only already defined nginx variables can be written to. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; location /foo {
     set $my_var &#39;&#39;; # this line is required to create $my_var at config time
     content_by_lua_block {
         ngx.var.my_var = 123;
         ...
     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;使用-nginx-内置绑定变量&#34;&gt;使用 Nginx 内置绑定变量&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt;作为一个成熟、久经考验的负载均衡软件，与其提供丰富、完整的内置变量是分不开的，它极大增加了对&lt;code&gt;Nginx&lt;/code&gt;网络行为的控制细度。这些变量大部分都是在请求进入时解析的，并把他们缓存到请求&lt;code&gt;cycle&lt;/code&gt;中，方便下一次获取使用。首先来看看&lt;code&gt;Nginx&lt;/code&gt;对都开放了那些&lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参看下表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$arg_name&lt;/td&gt;
&lt;td&gt;请求中的name参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$args&lt;/td&gt;
&lt;td&gt;请求中的参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$binary_remote_addr&lt;/td&gt;
&lt;td&gt;远程地址的二进制表示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$body_bytes_sent&lt;/td&gt;
&lt;td&gt;已发送的消息体字节数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$content_length&lt;/td&gt;
&lt;td&gt;HTTP请求信息里的&amp;rdquo;Content-Length&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$content_type&lt;/td&gt;
&lt;td&gt;请求信息里的&amp;rdquo;Content-Type&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$document_root&lt;/td&gt;
&lt;td&gt;针对当前请求的根路径设置值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$document_uri&lt;/td&gt;
&lt;td&gt;与$uri相同; 比如 /test2/test.php&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$host&lt;/td&gt;
&lt;td&gt;请求信息中的&amp;rdquo;Host&amp;rdquo;，如果请求中没有Host行，则等于设置的服务器名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$hostname&lt;/td&gt;
&lt;td&gt;机器名使用 gethostname系统调用的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_cookie&lt;/td&gt;
&lt;td&gt;cookie 信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_referer&lt;/td&gt;
&lt;td&gt;引用地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_user_agent&lt;/td&gt;
&lt;td&gt;客户端代理信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_via&lt;/td&gt;
&lt;td&gt;最后一个访问服务器的Ip地址。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$http_x_forwarded_for&lt;/td&gt;
&lt;td&gt;相当于网络访问路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$is_args&lt;/td&gt;
&lt;td&gt;如果请求行带有参数，返回“?”，否则返回空字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$limit_rate&lt;/td&gt;
&lt;td&gt;对连接速率的限制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$nginx_version&lt;/td&gt;
&lt;td&gt;当前运行的nginx版本号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$pid&lt;/td&gt;
&lt;td&gt;worker进程的PID&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$query_string&lt;/td&gt;
&lt;td&gt;与$args相同&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$realpath_root&lt;/td&gt;
&lt;td&gt;按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$remote_addr&lt;/td&gt;
&lt;td&gt;客户端IP地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$remote_port&lt;/td&gt;
&lt;td&gt;客户端端口号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$remote_user&lt;/td&gt;
&lt;td&gt;客户端用户名，认证用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request&lt;/td&gt;
&lt;td&gt;用户请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_body&lt;/td&gt;
&lt;td&gt;这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_body_file&lt;/td&gt;
&lt;td&gt;客户端请求主体信息的临时文件名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_completion&lt;/td&gt;
&lt;td&gt;如果请求成功，设为&amp;rdquo;OK&amp;rdquo;；如果请求未完成或者不是一系列请求中最后一部分则设为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_filename&lt;/td&gt;
&lt;td&gt;当前请求的文件路径名，比如/opt/nginx/www/test.php&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_method&lt;/td&gt;
&lt;td&gt;请求的方法，比如&amp;rdquo;GET&amp;rdquo;、&amp;rdquo;POST&amp;rdquo;等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$request_uri&lt;/td&gt;
&lt;td&gt;请求的URI，带参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$scheme&lt;/td&gt;
&lt;td&gt;所用的协议，比如http或者是https&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_addr&lt;/td&gt;
&lt;td&gt;服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_name&lt;/td&gt;
&lt;td&gt;请求到达的服务器名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_port&lt;/td&gt;
&lt;td&gt;请求到达的服务器端口号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$server_protocol&lt;/td&gt;
&lt;td&gt;请求的协议版本，&amp;rdquo;HTTP/1.0&amp;rdquo;或&amp;rdquo;HTTP/1.1&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$uri&lt;/td&gt;
&lt;td&gt;请求的URI，可能和最初的值有不同，比如经过重定向之类的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实这还不是全部，&lt;code&gt;Nginx&lt;/code&gt;在不停迭代更新是一个原因，还有一个是有些变量太冷门，借助它们，会有很多玩法。&lt;/p&gt;

&lt;p&gt;首先，在&lt;code&gt;OpenResty&lt;/code&gt;中如何引用这些变量呢？参考 &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxvarvariable&#34;&gt;ngx.var.VARIABLE&lt;/a&gt; 小节。&lt;/p&gt;

&lt;p&gt;利用这些内置变量，来做一个简单的数学求和运算例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;    server {
        listen    80;
        server_name  localhost;

        location /sum {
            #处理业务
           content_by_lua_block {
                local a = tonumber(ngx.var.arg_a) or 0
                local b = tonumber(ngx.var.arg_b) or 0
                ngx.say(&amp;quot;sum: &amp;quot;, a + b )
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜  ~  curl &#39;http://127.0.0.1/sum?a=11&amp;amp;b=12&#39;
sum: 23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;特别注意&lt;/strong&gt;
access_by_lua_content阶段取不到location中通过proxy_set_header设置的值&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;http://static.zybuluo.com/yishuailuo/1ur8ovkz7n5n36ojwas0t45l/image.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ngx.header.HEADER
syntax: ngx.header.HEADER = VALUE&lt;/p&gt;

&lt;p&gt;syntax: value = ngx.header.HEADER&lt;/p&gt;

&lt;p&gt;context: rewrite_by_lua&lt;em&gt;, access_by_lua&lt;/em&gt;, content_by_lua&lt;em&gt;, header_filter_by_lua&lt;/em&gt;, body_filter_by_lua&lt;em&gt;, log_by_lua&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Set, add to, or clear the current request&amp;rsquo;s HEADER response header that is to be sent.&lt;/p&gt;

&lt;p&gt;获取header值和赋值&lt;/p&gt;

&lt;p&gt;&amp;ndash; equivalent to ngx.header[&amp;ldquo;Content-Type&amp;rdquo;] = &amp;lsquo;text/plain&amp;rsquo;
 ngx.header.content_type = &amp;lsquo;text/plain&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;ngx.header[&amp;ldquo;X-My-Header&amp;rdquo;] = &amp;lsquo;blah blah&amp;rsquo;;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>